***

# Repository instructions for GitHub Copilot

## Общие принципы

- Всегда строго соблюдай принципы SOLID при генерации любого backend-кода на Python. Нарушение SOLID недопустимо ни в одном файле.
- Архитектура backend-а в этом проекте основана на CQRS. Не предлагай и не генерируй монолитные модели/сервисы, совмещающие команды и запросы.
- Строго разделяй области ответственности, не смешивай доменную логику, инфраструктуру и слой представления.
- Соблюдай принцип единственной ответственности (SRP) и для Python-классов, и для React-компонентов, и для хуков.

## Структура backend-проекта

- Структура разделена на **core** и **impl**:
  - В каталоге `core` находятся только интерфейсы, абстракции и контракты (протоколы, абстрактные классы, интерфейсы репозиториев, use case-ов и т.п.).
  - В каталоге `impl` находится реализация интерфейсов из `core` и конкретные адаптеры (ORM, HTTP, брокеры сообщений и т.п.).
- Никогда не помещай реализацию в `core` и не добавляй абстракции в `impl`. Любой новый интерфейс — в `core`, любая новая реализация — в `impl`.

## Именование файлов и классов (как в Java)

- Название файла должно **строго** совпадать с названием главного класса внутри него, с учётом регистра.
  - Примеры: `UserRepository.py`, `CreateOrderCommand.py`, `UserDto.py`.
- Не создавай файлы со строчными именами (например, `user_repository.py`, `models.py`, `utils.py` недопустимы).
- Каждый файл должен содержать один главный класс/модель/команду. Избегай "god objects" и файлов-свалок.

## Ограничение размеров файлов

- Не создавай и не расширяй файлы более чем примерно до 400 строк кода.
- При приближении к этому пределу предлагай/выполняй рефакторинг с выделением:
  - отдельных классов,
  - отдельных модулей,
  - дополнительных интерфейсов в `core` и реализаций в `impl`.
- Большие файлы необходимо декомпозировать, а не дополнять.

## Модели Pydantic и CQRS-модели

- Каждую Pydantic-модель размещай в **отдельном файле** с названием, совпадающим с именем модели.
  - Примеры: `UserReadModel.py`, `UserCreateDto.py`, `OrderItemDto.py`.
- Не складывай все Pydantic-модели в один файл.
- То же правило для CQRS-команд и запросов:
  - `CreateUserCommand.py`, `UpdateUserCommand.py`, `GetUserQuery.py` и т.п. — каждый в отдельном файле.
- Разделяй read-модели (query side) и write-модели (command side) по файлам и, при необходимости, по пакетам.

## CQRS и слои

- Для команд (write side) используй отдельные command-handler-ы с чётким интерфейсом в `core` и их реализацией в `impl`.
- Для запросов (read side) используй отдельные query-handler-ы, не смешивая их с командами.
- Не объединяй командные и запросные сценарии в одном классе или файле.
- Не перемешивай доменные сущности, DTO и транспортные модели: каждый тип — отдельный класс и при необходимости отдельный файл.

***

## Frontend: общие правила

Проект использует React и Tailwind CSS v4. Требования распространяются на все компоненты, хуки и вспомогательные модули.

- Все компоненты должны быть **чистыми функциями**: одинаковые props → одинаковый JSX без побочных эффектов.
- Следи за SRP: один компонент — одна понятная ответственность.
- Организуй структуру по принципу **feature folders**: в одной папке фичи держи компоненты, стили, хуки и тесты этой фичи.
- Избегай "гигантских" компонентов; при росте логики выноси:
  - состояние и бизнес-логику в кастомные хуки,
  - подкомпоненты в отдельные файлы.

## Деструктуризация и именование

- В начале каждого компонента деструктурируй `props`, чтобы явно видеть зависимости компонента.
  - Пример (по стилю, не по коду): `const { userId, onSubmit } = props;`.
- Используй осмысленные имена переменных, функций и компонентов:
  - избегай сокращений и нечитаемых аббревиатур,
  - не используй однобуквенные имена, кроме индексов коротких итераций.
- Будь последовательным в стиле импортов и экспортов:
  - по возможности предпочитай именованные экспорты,
  - избегай смешивания default и named экспортов в одном модуле без необходимости.

## Хуки и логика

- Всю нетривиальную бизнес-логику и работу с состоянием выноси в **кастомные хуки**.
  - Примеры: `useUserForm`, `useOrdersList`, `useDebouncedSearch`.
- По возможности избегай громоздких `if/else` и `switch` в JSX:
  - используй объекты-маппинги и декларативные структуры данных для выбора вариантов отображения.
- Не выполняй побочных эффектов внутри рендера компонента:
  - эффекты размещай в `useEffect`,
  - побочные операции — в хуках или в сервисных слоях.

## Стилизация и Tailwind CSS v4

- Tailwind CSS v4 — **основной** инструмент стилизации:
  - применяй utility-классы прямо в JSX,
  - не используй inline-стили, если нет крайне веской причины.
- Конфигурация `tailwind.config.js`:
  - опирайся на семантические токены (`bg-primary`, `text-muted`, spacing-токены и т.п.),
  - избегай произвольных значений (arbitrary values) вне заранее определённых токенов.
- Используй `@apply` только в редких случаях, когда utility-паттерн действительно многократно повторяется.
- Включай JIT и следи, чтобы не плодить неиспользуемые классы; в продакшене должен работать purge/tree-shaking.

## Tailwind-классы и читаемость

- Группируй классы в следующем порядке:
  - responsive-модификаторы (`sm:`, `md:`, `lg:`),
  - state-модификаторы (`hover:`, `focus:`, `active:`),
  - базовые стили (layout, spacing, цвет, типографика).
- Для условных классов используй `clsx` или `cn`-хелпер (например, из `class-variance-authority` или `tailwind-merge`), не применяй конкатенацию строк вручную.
- Ограничивай количество Tailwind-классов на одном элементе примерно 10–15:
  - при превышении порога выноси часть стилей в подкомпонент или в `@apply`.

## Компоненты и дизайн-система

- Строй дизайн-систему на базе Tailwind-токенов:
  - единая шкала отступов (spacing),
  - типографика,
  - цветовая палитра.
- Отдавай предпочтение **headless-компонентам** по аналогии с `shadcn/ui`:
  - логика отделена от стилей,
  - `className` передаётся как проп и может переопределяться снаружи.
- Не создавай тяжёлые, монолитные UI-компоненты; используй композицию:
  - собирай интерфейсы из небольших переиспользуемых строительных блоков.

## Оптимизация и производительность фронтенда

- Следи за тем, чтобы строки классов, особенно динамические, не вычислялись на каждый рендер без необходимости:
  - при сложной динамике мемоизируй вычисление классов через `useMemo`.
- Используй возможности Tailwind v4 по JIT и treeshaking, чтобы CSS-бандл оставался минимальным.
- Избегай лишних ререндеров:
  - по необходимости применяй `React.memo`,
  - выноси тяжёлые вычисления в хуки с мемоизацией.

***

## Как использовать эти инструкции

- При генерации или продолжении кода:
  - соблюдай разделение `core`/`impl` и CQRS,
  - соблюдай правила именования файлов и классов как в Java,
  - не создавай файлы > 400 строк и не складируй много моделей/команд в одну единицу,
  - на фронтенде следуй правилам для чистых компонентов, хуков и Tailwind v4.
- Если пользовательский запрос противоречит этим правилам, предлагай вариант решения, который **сохраняет** данные ограничения, и явно указывай на нарушение, которого следует избегать.