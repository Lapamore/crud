docker system prune -a --volumes
docker-compose up --build -d app


docker-compose exec app alembic revision --autogenerate -m "Initial migration"
docker-compose exec app alembic upgrade head

curl -X 'POST' \
    'http://localhost:8001/api/users' \
    -H 'accept: application/json' \
    -H 'Content-Type: application/json' \
    -d '{
    "email": "user1@example.com",
    "username": "testuser1",
    "password": "password123"
}'


curl -X 'POST' \
  'http://localhost:8001/api/users/login' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/x-www-form-urlencoded' \
  -d 'username=testuser1&password=password123'





curl -X 'POST' \
  'http://localhost:8001/api/articles' \
  -H 'accept: application/json' \
  -H 'Authorization: Bearer <ВАШ_ТОКЕН>' \
  -H 'Content-Type: application/json' \
  -d '{
  "title": "My First Article",
  "description": "This is a test article.",
  "body": "The content of the article goes here."
}'

curl -X 'PUT' \
  'http://localhost:8001/api/articles/my-second-article' \
  -H 'accept: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0dXNlcjEiLCJleHAiOjE3NjE0OTI5MTN9.oP5dDV9qfpCE1549X972Zsz19r0LdB_S5tB962z1ed0' \
  -H 'Content-Type: application/json' \
  -d '{
  "title": "My Updated Article Title",
  "description": "The description has been updated.",
  "body": "The body has been updated as well."
}'

curl -X 'DELETE' \
  'http://localhost:8001/api/articles/my-updated-article-title' \
  -H 'accept: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0dXNlcjEiLCJleHAiOjE3NjE0OTI5MTN9.oP5dDV9qfpCE1549X972Zsz19r0LdB_S5tB962z1ed0'

  curl -X 'DELETE' \
  'http://localhost:8001/api/articles/' \
  -H 'accept: application/json' \
  -H 'Authorization: Bearer <ВАШ_ТОКЕН>'



curl -X 'POST' \
  'http://localhost:8001/api/articles' \
  -H 'accept: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0dXNlcjEiLCJleHAiOjE3NjE0OTI5MTN9.oP5dDV9qfpCE1549X972Zsz19r0LdB_S5tB962z1ed0' \
  -H 'Content-Type: application/json' \
  -d '{
  "title": "Article for Comments",
  "description": "A test article.",
  "body": "This article exists to be commented on."
}'

curl -X 'GET' \
  'http://localhost:8001/api/user' \
  -H 'accept: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0dXNlcjQiLCJleHAiOjE3NjE0OTY2NjF9.shQKNMdMyn-z-W5b5Qi48vYRFuKFhJpl3W7y9CCWbQY'


// src/api/copilot.ts

import { Chat, Message } from '../types';
import { API_PATH } from '../utils';

async function agentApiRequest<T>(
  baseURL: string,
  action: string,
  params: object
): Promise<T> {
  const fullUrl = `${baseURL}/agent_console/prod/v1/`; 

  const response = await fetch(fullUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ action, params }),
  });

  if (!response.ok) {
    const errorBody = await response.text();
    console.error(`API Error for action "${action}":`, errorBody);
    try {
      const errorJson = JSON.parse(errorBody);
      if (errorJson.detail) {
        throw new Error(errorJson.detail);
      }
    } catch (e) {
    }
    throw new Error(`Request failed with status ${response.status}: ${errorBody}`);
  }

  return response.json();
}

export async function sendToCopilot(
  baseURL: string, 
  payload: {
    user_id: string;
    first_message: boolean;
    dialog_id: string | null;
    user_prompt: string;
  }
): Promise<{ dialog_id?: string | null; message?: string | null; history?: Array<any> | null }> {
  
  const fullUrl = `${baseURL}${API_PATH}`;

  const res = await fetch(fullUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });

  if (!res.ok) {
      const errorBody = await res.text();
      throw new Error(`Network response was not ok: ${res.statusText} - ${errorBody}`);
  }

  const json = await res.json();
  return json ?? {};
}

export async function pollAgentMessages(
  baseURL: string,
  payload: { user_id: string; dialog_id: string },
  signal: AbortSignal
): Promise<{ message: { text: string; role: 'agent' | 'system'; status?: 'closed' } | null }> {
  const response = await fetch(`${baseURL}/agent_console/prod/v1/`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      action: 'get_agent_messages',
      params: {
        user_id: payload.user_id,
        session_id: payload.dialog_id,
      },
    }),
    signal,
  });

  if (!response.ok) {
    if (signal.aborted) {
        throw new DOMException('Aborted', 'AbortError');
    }
    throw new Error(`Не удалось получить сообщения от сотрудника: ${response.statusText}`);
  }
  return response.json();
}

export async function sendToAgent(
  baseURL: string,
  payload: {
    user_id: string;
    dialog_id: string;
    user_prompt: string;
  }
): Promise<{ status: 'sent' }> {
  return agentApiRequest(baseURL, 'send_user_message_to_agent', {
    user_id: payload.user_id,
    session_id: payload.dialog_id,
    text: payload.user_prompt,
  });
}

export function pickReplyText(resp: { message?: string | null; history?: any[] | null }): string {
  if (resp?.message) return String(resp.message);
  const hist = resp?.history ?? [];
  const lastAi = [...hist].reverse().find((m: any) => m?.type === 'ai' && m?.content);
  return lastAi?.content ?? 'Готово.';
}

export async function fetchUserDialogs(baseURL: string, userId: string): Promise<Chat[]> {
  const response = await agentApiRequest<{ dialogs: any[] }>(baseURL, 'get_user_dialogs', { user_id: userId });
  const dialogs = response.dialogs || [];
  
  return dialogs.map((d: any) => ({
    id: d.id,
    title: `Диалог от ${new Date(d.created_at).toLocaleDateString('ru-RU')}`,
    dialogId: d.id,
    status: d.status,
  }));
}

export async function fetchDialogHistory(
  baseURL: string,
  payload: { user_id: string; dialog_id: string }
): Promise<Message[]> {
  const response = await agentApiRequest<{ history: any[] }>(baseURL, 'get_dialog_history', {
    user_id: payload.user_id,
    session_id: payload.dialog_id,
  });

  const history = response.history || [];

  // --- ИЗМЕНЕНИЯ ЗДЕСЬ ---
  // 1. Фильтруем системные сообщения.
  // 2. Корректно определяем роль 'agent'.
  return history
    .filter((msg: any) => msg.role !== 'system')
    .map((msg: any, index: number) => ({
      id: msg.message_id?.toString() || String(Date.now() + index),
      from: msg.role === 'user' ? 'me' : (msg.role === 'agent' ? 'agent' : 'bot'),
      text: msg.content || '',
    }));
  // --- КОНЕЦ ИЗМЕНЕНИЙ ---
}

export async function deleteDialog(
  baseURL: string,
  payload: { user_id: string; session_id: string }
): Promise<void> {
  await agentApiRequest(baseURL, 'delete_dialog', payload);
}


import React, { useEffect, useMemo, useRef, useState, useCallback } from 'react';
import { ThemeProvider, Stack } from 'ui-kit';

import { Chat, Message, ChatWidgetProps} from './types';
import { themeFromKey, LS_ACTIVE } from './utils';
import { 
    pickReplyText, 
    sendToCopilot, 
    fetchUserDialogs, 
    fetchDialogHistory, 
    deleteDialog,
    pollAgentMessages,
    sendToAgent
} from './api/copilot';
import ActiveChatPanel from './components/ActiveChatPanel';
import ChatListPanel from './components/ChatListPanel';

const ChatWidget: React.FC<ChatWidgetProps> = ({ userId, baseURL, themeKey }) => {
  
  const [chats, setChats] = useState<Chat[]>([]);
  const [activeChatId, setActiveChatId] = useState<string>('');
  const [messagesMap, setMessagesMap] = useState<Record<string, Message[]>>({});
  const [draft, setDraft] = useState<string>('');
  const [typingMap, setTypingMap] = useState<Record<string, boolean>>({});
  const [loading, setLoading] = useState(true);

  const listRef = useRef<HTMLDivElement>(null);
  const chatsRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  const messages = activeChatId ? (messagesMap[activeChatId] ?? []) : [];
  const isTyping = !!typingMap[activeChatId];
  const activeTitle = useMemo(() => chats.find(c => c.id === activeChatId)?.title ?? 'Чат', [activeChatId, chats]);

  useEffect(() => { if (activeChatId) localStorage.setItem(LS_ACTIVE, activeChatId); }, [activeChatId]);

  useEffect(() => {
    const loadDialogs = async () => {
      if (!userId || !baseURL) return;
      try {
        setLoading(true);
        const loadedChats = await fetchUserDialogs(baseURL, userId);
        setChats(loadedChats);
        const savedActive = localStorage.getItem(LS_ACTIVE);
        if (savedActive && loadedChats.some(c => c.id === savedActive)) {
          setActiveChatId(savedActive);
        } else if (loadedChats.length > 0) {
          setActiveChatId(loadedChats[0].id);
        }
      } catch (error) {
        console.error("Ошибка загрузки диалогов:", error);
      } finally {
        setLoading(false);
      }
    };
    loadDialogs();
  }, [userId, baseURL]);

  const loadMessages = useCallback(async () => {
    if (!activeChatId || !userId || !baseURL) return;
    const chat = chats.find(c => c.id === activeChatId);
    if (!chat?.dialogId) {
      setMessagesMap(prev => ({ ...prev, [activeChatId]: [] }));
      return;
    }
    try {
      const messages = await fetchDialogHistory(baseURL, {
        user_id: userId,
        dialog_id: chat.dialogId,
      });
      setMessagesMap(prev => ({ ...prev, [activeChatId]: messages }));
    } catch (error) {
      console.error("Ошибка загрузки истории:", error);
      setMessagesMap(prev => ({ ...prev, [activeChatId]: [] }));
    }
  }, [activeChatId, userId, baseURL, chats]);

  useEffect(() => {
    loadMessages();
  }, [loadMessages]);
  
  const handleCreateChat = useMemo(() => () => {
    const newId = String(Date.now());
    setChats(prev => [...prev, { id: newId, title: `Новый чат ${prev.length + 1}`, dialogId: null, status: 'AI_HANDLED' }]);
    setMessagesMap(prev => ({ ...prev, [newId]: [] }));
    setActiveChatId(newId);
    requestAnimationFrame(() => {
      if (chatsRef.current) chatsRef.current.scrollTop = chatsRef.current.scrollHeight;
      inputRef.current?.focus();
    });
  }, []);

  useEffect(() => {
    if (listRef.current) listRef.current.scrollTop = listRef.current.scrollHeight;
  }, [messages.length, isTyping]);
  
  const handleSend = async () => {
    const text = draft.trim();
    if (!text || !activeChatId || !userId || !baseURL) return;

    const chat = chats.find(c => c.id === activeChatId);
    if (!chat) return;

    const isAgentChat = chat.status === 'AGENT_HANDLED';
    const messageId = String(Date.now());

    setMessagesMap(prev => ({
      ...prev,
      [activeChatId]: [...(prev[activeChatId] ?? []), { id: messageId, from: 'me', text }],
    }));
    setDraft('');
    
    const isFirstMessage = (messagesMap[activeChatId]?.length ?? 0) === 1;
    if (isFirstMessage && !chat.dialogId) {
        const newTitle = text.length > 30 ? text.substring(0, 27) + '...' : text;
        setChats(prev => prev.map(c => (c.id === activeChatId ? { ...c, title: newTitle } : c)));
    }

    if (isAgentChat && chat.dialogId) {
      try {
        await sendToAgent(baseURL, {
          user_id: userId,
          dialog_id: chat.dialogId,
          user_prompt: text,
        });
      } catch (e) {
        console.error('Ошибка отправки сообщения сотруднику:', e);
        setMessagesMap(prev => ({
            ...prev,
            [activeChatId]: prev[activeChatId].map(m => 
                m.id === messageId ? { ...m, text: `${m.text} (Ошибка отправки)` } : m
            ),
        }));
      }
    } else {
      setTypingMap(prev => ({ ...prev, [activeChatId]: true }));
      try {
        const resp = await sendToCopilot(baseURL, {
          user_id: userId,
          first_message: isFirstMessage,
          dialog_id: chat.dialogId ?? null,
          user_prompt: text
        });

        const updatedDialogId = resp.dialog_id ? String(resp.dialog_id) : chat.dialogId;
        if (updatedDialogId && updatedDialogId !== chat.dialogId) {
          setChats(prev => prev.map(c => c.id === activeChatId ? { ...c, dialogId: updatedDialogId, status: 'AI_HANDLED' } : c));
        }

        const reply = pickReplyText(resp);
        const rid = String(Date.now() + 1);
        setMessagesMap(prev => ({ ...prev, [activeChatId]: [...(prev[activeChatId] ?? []), { id: rid, from: 'bot', text: reply }] }));
      } catch (e) {
        console.error(e);
        const rid = String(Date.now() + 1);
        setMessagesMap(prev => ({ ...prev, [activeChatId]: [...(prev[activeChatId] ?? []), { id: rid, from: 'bot', text: 'Не удалось получить ответ от сервера.' }] }));
      } finally {
        setTypingMap(prev => ({ ...prev, [activeChatId]: false }));
        requestAnimationFrame(() => inputRef.current?.focus());
      }
    }
  };

  useEffect(() => {
    const activeChat = chats.find(c => c.id === activeChatId);

    if (abortControllerRef.current) {
        abortControllerRef.current.abort();
    }

    if (!activeChat?.dialogId || !['AGENT_HANDLED', 'AWAITING_AGENT'].includes(activeChat.status!)) {
      return;
    }

    const controller = new AbortController();
    abortControllerRef.current = controller;

    const poll = async () => {
        console.log(`Polling started for dialog: ${activeChat.dialogId}`);
        while (!controller.signal.aborted) {
            try {
                const data = await pollAgentMessages(baseURL, { user_id: userId, dialog_id: activeChat.dialogId! }, controller.signal);

                if (controller.signal.aborted) {
                    console.log(`Polling aborted for dialog: ${activeChat.dialogId}`);
                    break;
                }

                if (data.message) {
                    console.log("New message received:", data.message);
                    const { text, role, status } = data.message;
                    
                    if (status === 'closed') {
                        setMessagesMap(prev => ({ ...prev, [activeChatId]: [...(prev[activeChatId] ?? []), { id: String(Date.now()), from: 'bot', text: text }] }));
                        setChats(prev => prev.map(c => c.id === activeChatId ? { ...c, status: 'CLOSED' } : c));
                        break;
                    }

                    if (role === 'agent') {
                        setMessagesMap(prev => ({ ...prev, [activeChatId]: [...(prev[activeChatId] ?? []), { id: String(Date.now()), from: 'agent', text: text }] }));
                        if (activeChat.status === 'AWAITING_AGENT') {
                            setChats(prev => prev.map(c => c.id === activeChatId ? { ...c, status: 'AGENT_HANDLED' } : c));
                        }
                    }
                }
            } catch (e: any) {
                if (e.name !== 'AbortError') {
                    console.error('Long-polling ошибка:', e);
                    await new Promise(resolve => setTimeout(resolve, 5000));
                } else {
                    console.log("Polling aborted via signal.");
                }
            }
        }
        console.log(`Polling stopped for dialog: ${activeChat.dialogId}`);
    };

    poll();

    return () => {
      console.log("Cleanup: aborting controller.");
      controller.abort();
    };
  }, [activeChatId, chats, baseURL, userId]);

  const removeChatLocally = (idToDelete: string) => {
    const remainingChats = chats.filter(c => c.id !== idToDelete);
    setChats(remainingChats);
    setMessagesMap(prev => {
      const newMap = { ...prev };
      delete newMap[idToDelete];
      return newMap;
    });
  
    if (activeChatId === idToDelete) {
      setActiveChatId(remainingChats[0]?.id ?? '');
    }
  };

  const deleteChat = async (idToDelete: string) => {
    const chatToDelete = chats.find(c => c.id === idToDelete);
    
    removeChatLocally(idToDelete);
  
    if (chatToDelete?.dialogId) {
      deleteDialog(baseURL, {
        user_id: userId,
        session_id: chatToDelete.dialogId,
      }).catch((error) => {
        console.error("Ошибка удаления диалога на сервере:", error);
        setChats(prev => [...prev, chatToDelete]);
        alert("Не удалось удалить диалог. Повторите попытку.");
      });
    }
  };

  if (loading) {
    return (
      <ThemeProvider theme={themeFromKey(themeKey)}>
        <div style={{ padding: 20, textAlign: 'center' }}>
          Загрузка диалогов...
        </div>
      </ThemeProvider>
    );
  }

  return (
    <ThemeProvider theme={themeFromKey(themeKey)}>
      <Stack direction="row" fullWidth style={{ height: '100vh' }}>
        <ChatListPanel
          chats={chats}
          activeChatId={activeChatId}
          chatsRef={chatsRef}
          setActiveChatId={setActiveChatId}
          handleCreateChat={handleCreateChat}
          deleteChat={deleteChat}
        />
        <ActiveChatPanel
          chats={chats}
          activeTitle={activeTitle}
          messages={messages}
          isTyping={isTyping}
          draft={draft}
          listRef={listRef}
          inputRef={inputRef}
          setDraft={setDraft}
          handleSend={handleSend}
        />
      </Stack>
    </ThemeProvider>
  );
};

export default ChatWidget;







// src/components/ActiveChatPanel.tsx

import React from 'react';
import { Stack, CroppedText, Grid, Card, Avatar, Loader, Input, IconButton, Alert } from 'ui-kit'; // Добавлен Alert
import { Message } from '../types';
import { bubbleStyle } from '../utils';
import { SendIcon, SparkIcon, AgentIcon } from './icons';
import MdMessage from './MdMessage';
import { ActiveChatPanelProps } from '../types'; // Импортируем обновленный тип

const ActiveChatPanel: React.FC<ActiveChatPanelProps> = ({
  chats,
  activeTitle,
  messages,
  isTyping,
  draft,
  listRef,
  inputRef,
  setDraft,
  handleSend,
  isChatClosed, // Получаем новое свойство
}) => {

  const renderAvatar = (from: Message['from']) => {
    // ... (код renderAvatar остается без изменений)
  };

  return (
    <Stack direction="column" fullWidth style={{ flex: 1, minHeight: 0 }}>
      {/* ... Заголовок чата ... */}
      
      <div ref={listRef} style={{ overflowY: 'auto', flex: 1, minHeight: 0 }}>
        {/* ... Рендер сообщений ... */}
      </div>

      {/* ++ ИЗМЕНЕНИЯ ЗДЕСЬ ++ */}
      <Stack direction="column" gap="8px" style={{ padding: '12px 16px', borderTop: '1px solid var(--ui-kit-colors-border-primary)' }}>
        {isChatClosed && (
          <Alert color="secondary" hideClose>
            Диалог был завершен. Вы не можете отправлять новые сообщения.
          </Alert>
        )}
        <Stack direction="row" gap="8px">
          <Input
            ref={inputRef as any}
            fullWidth
            placeholder={isChatClosed ? "Диалог завершен" : "Напишите сообщение…"}
            value={draft}
            onChange={(e: any) => setDraft(e.target.value)}
            onKeyDown={(e: any) => { if (e.key === 'Enter') handleSend() }}
            style={{ minHeight: 44 }}
            disabled={chats.length === 0 || isChatClosed} // Блокируем поле
          />
          <IconButton
            icon={SendIcon}
            variant="contained"
            color="primary"
            onClick={handleSend}
            title="Отправить"
            disabled={!draft.trim() || chats.length === 0 || isChatClosed} // Блокируем кнопку
            loading={isTyping}
          />
        </Stack>
      </Stack>
      {/* -- КОНЕЦ ИЗМЕНЕНИЙ -- */}
    </Stack>
  );
};

export default ActiveChatPanel;

// src/ChatWidget.tsx

import React, { useEffect, useMemo, useRef, useState, useCallback } from 'react';
import { ThemeProvider, Stack } from 'ui-kit';
import { Chat, Message, ChatWidgetProps } from './types';
import { themeFromKey, LS_ACTIVE } from './utils';
import {
  pickReplyText,
  sendToCopilot,
  fetchUserDialogs,
  fetchDialogHistory,
  deleteDialog,
  pollAgentMessages,
  sendToAgent,
} from './api/copilot';
import ActiveChatPanel from './components/ActiveChatPanel';
import ChatListPanel from './components/ChatListPanel';

const ChatWidget: React.FC<ChatWidgetProps> = ({ userId, baseURL, themeKey }) => {
  // ... (все существующие хуки useState, useRef и т.д. остаются без изменений) ...

  const [chats, setChats] = useState<Chat[]>([]);
  const [activeChatId, setActiveChatId] = useState<string>('');
  const [messagesMap, setMessagesMap] = useState<Record<string, Message[]>>({});
  const [draft, setDraft] = useState<string>('');
  const [typingMap, setTypingMap] = useState<Record<string, boolean>>({});
  const [loading, setLoading] = useState(true);

  const listRef = useRef<HTMLDivElement>(null);
  const chatsRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  const activeChat = useMemo(() => chats.find(c => c.id === activeChatId), [activeChatId, chats]);
  const messages = activeChatId ? (messagesMap[activeChatId] ?? []) : [];
  const isTyping = !!typingMap[activeChatId];
  const activeTitle = activeChat?.title ?? 'Чат';
  const isChatClosed = activeChat?.status === 'CLOSED';

  // ... (useEffect для LS_ACTIVE, loadDialogs, loadMessages, handleCreateChat, useEffect для скролла) ...

  const handleSend = async () => {
    if (isChatClosed) return; // Дополнительная проверка на случай, если пользователь успеет нажать
    // ... (остальной код handleSend остается без изменений) ...
  };

  // ++ ИЗМЕНЕНИЯ В ЛОГИКЕ POLLING ++
  useEffect(() => {
    const activeChat = chats.find(c => c.id === activeChatId);

    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    if (!activeChat?.dialogId || !['AGENT_HANDLED', 'AWAITING_AGENT'].includes(activeChat.status!)) {
      return;
    }

    const controller = new AbortController();
    abortControllerRef.current = controller;

    const poll = async () => {
      console.log(`Polling started for dialog: ${activeChat.dialogId}`);
      while (!controller.signal.aborted) {
        try {
          const data = await pollAgentMessages(baseURL, { user_id: userId, dialog_id: activeChat.dialogId! }, controller.signal);

          if (controller.signal.aborted) {
            console.log(`Polling aborted for dialog: ${activeChat.dialogId}`);
            break;
          }

          if (data.message) {
            const { text, role, status } = data.message;
            
            // --- ОБРАБОТКА ЗАКРЫТИЯ ДИАЛОГА ---
            if (status === 'closed') {
              setMessagesMap(prev => ({ ...prev, [activeChatId]: [...(prev[activeChatId] ?? []), { id: String(Date.now()), from: 'bot', text }] }));
              setChats(prev => prev.map(c => c.id === activeChatId ? { ...c, status: 'CLOSED' } : c));
              break; // Выходим из цикла, так как диалог закрыт
            }
            // --- КОНЕЦ ОБРАБОТКИ ---

            if (role === 'agent') {
              setMessagesMap(prev => ({ ...prev, [activeChatId]: [...(prev[activeChatId] ?? []), { id: String(Date.now()), from: 'agent', text }] }));
              if (activeChat.status === 'AWAITING_AGENT') {
                setChats(prev => prev.map(c => c.id === activeChatId ? { ...c, status: 'AGENT_HANDLED' } : c));
              }
            }
          }
        } catch (e: any) {
          if (e.name !== 'AbortError') {
            console.error('Long-polling ошибка:', e);
            await new Promise(resolve => setTimeout(resolve, 5000));
          } else {
            console.log("Polling aborted via signal.");
          }
        }
      }
      console.log(`Polling stopped for dialog: ${activeChat.dialogId}`);
    };

    poll();

    return () => {
      console.log("Cleanup: aborting controller.");
      controller.abort();
    };
  }, [activeChatId, chats, baseURL, userId]);
  // -- КОНЕЦ ИЗМЕНЕНИЙ --

  // ... (остальные функции: removeChatLocally, deleteChat) ...
  
  if (loading) {
    // ...
  }

  return (
    <ThemeProvider theme={themeFromKey(themeKey)}>
      <Stack direction="row" fullWidth style={{ height: '100vh' }}>
        <ChatListPanel
          chats={chats}
          activeChatId={activeChatId}
          chatsRef={chatsRef}
          setActiveChatId={setActiveChatId}
          handleCreateChat={handleCreateChat}
          deleteChat={deleteChat}
        />
        {/* ++ ПЕРЕДАЕМ НОВЫЙ PROP ++ */}
        <ActiveChatPanel
          chats={chats}
          activeTitle={activeTitle}
          messages={messages}
          isTyping={isTyping}
          draft={draft}
          listRef={listRef}
          inputRef={inputRef}
          setDraft={setDraft}
          handleSend={handleSend}
          isChatClosed={isChatClosed} 
        />
        {/* -- КОНЕЦ -- */}
      </Stack>
    </ThemeProvider>
  );
};

export default ChatWidget;



