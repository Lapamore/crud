docker system prune -a --volumes
docker-compose up --build -d app


docker-compose exec app alembic revision --autogenerate -m "Initial migration"
docker-compose exec app alembic upgrade head


docker stop $(docker ps -a -q) && docker system prune -a && docker-compose up --build -d
docker system prune -a
docker-compose up --build -d

docker-compose exec users-api alembic revision --autogenerate -m "Create users table" && docker-compose exec backend alembic revision --autogenerate -m "Create articles and comments tables"

Открыл оба Swagger UI:

Backend (Articles, Comments): http://localhost/docs
Users Service: http://localhost/users/docs


# Для основного сервиса
docker-compose exec backend alembic revision --autogenerate -m "Create articles and comments tables"

docker-compose exec users-api alembic upgrade head
docker-compose exec backend alembic upgrade head


Конечно! Вот полная и подробная инструкция по всем запросам к вашему API.

Этот гайд можно использовать как "шпаргалку" для тестирования, демонстрации или как основу для документации. Мы будем использовать curl и сохранять токен и slug в переменные для удобства.

Инструкция по тестированию API микросервисного приложения

Предварительные требования:

Все 5 контейнеров (api-gateway, backend, users-api, db-main, db-users) запущены.

Миграции успешно применены к обеим базам данных.

У вас открыт терминал (командная строка).

Золотое правило: Все запросы отправляются на единый адрес http://localhost. Nginx (API Gateway) сам распределит их по нужным сервисам.

Часть 1: Регистрация и получение токена

Сначала нам нужно создать пользователя и получить токен для доступа к защищенным ресурсам.

1.1. Регистрация пользователя

Этот запрос будет обработан сервисом users-api.

code
Bash
download
content_copy
expand_less
curl -i -X POST "http://localhost/api/users" \
-H "Content-Type: application/json" \
-d '{
  "email": "dima@example.com",
  "username": "dima",
  "password": "superpassword123"
}'

Результат: Вы увидите ответ с HTTP-статусом 201 Created и JSON с данными вашего нового пользователя.

1.2. Вход и сохранение токена в переменную

Этот запрос также пойдет в users-api.

code
Bash
download
content_copy
expand_less
# Выполняем запрос и сразу извлекаем токен с помощью утилиты `jq`
TOKEN=$(curl -s -X POST "http://localhost/api/users/login" \
-H "Content-Type: application/x-www-form-urlencoded" \
-d "username=dima&password=superpassword123" | jq -r .access_token)

Результат: Токен доступа будет сохранен в переменную TOKEN.

Проверка: Выполните echo $TOKEN, чтобы убедиться, что токен на месте.

Часть 2: Управление пользователем

Теперь, имея токен, мы можем управлять профилем. Эти запросы также обрабатывает users-api.

2.1. Получение информации о себе
code
Bash
download
content_copy
expand_less
curl -i -H "Authorization: Bearer $TOKEN" http://localhost/api/user

Результат: Статус 200 OK и JSON с полной информацией о вашем пользователе.

2.2. Обновление своего профиля
code
Bash
download
content_copy
expand_less
curl -i -X PUT "http://localhost/api/user" \
-H "Content-Type: application/json" \
-H "Authorization: Bearer $TOKEN" \
-d '{
  "bio": "Разработчик микросервисов на FastAPI."
}'

Результат: Статус 200 OK и JSON с обновленными данными.

Часть 3: Работа со статьями (CRUD)

Эти запросы будут перенаправлены в сервис backend.

3.1. Создание статьи
code
Bash
download
content_copy
expand_less
curl -i -X POST "http://localhost/api/articles" \
-H "Content-Type: application/json" \
-H "Authorization: Bearer $TOKEN" \
-d '{
  "title": "Тестовая Статья для API",
  "description": "Проверяем создание статей",
  "body": "Этот текст был создан через curl.",
  "tagList": ["api", "test"]
}'

Результат: Статус 201 Created и JSON с данными новой статьи. Обязательно скопируйте значение поля slug из ответа.

3.2. Сохранение slug в переменную
code
Bash
download
content_copy
expand_less
# Замените на slug, который вы получили на шаге 3.1
SLUG="testovaia-statia-dlia-api"
3.3. Получение списка всех статей
code
Bash
download
content_copy
expand_less
curl -i http://localhost/api/articles

Результат: Статус 200 OK и JSON-массив со всеми статьями.

3.4. Получение одной статьи по slug
code
Bash
download
content_copy
expand_less
curl -i http://localhost/api/articles/$SLUG

Результат: Статус 200 OK и JSON с данными конкретной статьи.

3.5. Обновление статьи
code
Bash
download
content_copy
expand_less
curl -i -X PUT "http://localhost/api/articles/$SLUG" \
-H "Content-Type: application/json" \
-H "Authorization: Bearer $TOKEN" \
-d '{
  "body": "Этот текст был обновлен через curl."
}'

Результат: Статус 200 OK и JSON с обновленной статьей.

Часть 4: Работа с комментариями

Эти запросы также обрабатывает backend. Мы будем использовать статью, созданную в Части 3.

4.1. Добавление комментария
code
Bash
download
content_copy
expand_less
curl -i -X POST "http://localhost/api/articles/$SLUG/comments" \
-H "Content-Type: application/json" \
-H "Authorization: Bearer $TOKEN" \
-d '{
  "body": "Мой первый комментарий!"
}'

Результат: Статус 201 Created и JSON с данными комментария. Запомните его id (например, 1).

4.2. Получение всех комментариев статьи
code
Bash
download
content_copy
expand_less
curl -i http://localhost/api/articles/$SLUG/comments

Результат: Статус 200 OK и JSON-массив со всеми комментариями к этой статье.

4.3. Удаление комментария

Замените 1 в конце URL на id комментария, который вы получили на шаге 4.1.

code
Bash
download
content_copy
expand_less
curl -i -X DELETE -H "Authorization: Bearer $TOKEN" http://localhost/api/articles/$SLUG/comments/1

Результат: Статус 204 No Content и пустой ответ.

Часть 5: Финальная очистка

Давайте удалим статью, которую создали.

5.1. Удаление статьи
code
Bash
download
content_copy
expand_more

Результат: Статус 204 No Content и пустой ответ.

Готово! Вы успешно протестировали полный цикл жизни сущностей в вашем микросервисном приложении.